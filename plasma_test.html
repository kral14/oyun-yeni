<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plazma Q√ºll…ôsi Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #gameCanvas {
            background: #1a1a2e;
            border: 2px solid #00d4ff;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
            cursor: crosshair;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 25, 0.9);
            padding: 15px;
            border: 1px solid #00d4ff;
            border-radius: 8px;
            color: #00d4ff;
            font-size: 14px;
        }
        
        .controls button {
            margin: 5px;
            padding: 8px 15px;
            background: linear-gradient(45deg, #4a90e2, #357abd);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-weight: bold;
        }
        
        .controls button:hover {
            background: linear-gradient(45deg, #5aa0f2, #458acd);
        }
    </style>
</head>
<body>
    <div class="controls">
        <div>üîµ Plazma Q√ºll…ôsi Test</div>
        <div style="margin-top: 10px; font-size: 12px; color: #a0a0a0;">
            Sol klik: Direk qoy<br>
            Direkl…ôr arasƒ±ndan lazer ke√ß…ôc…ôk
        </div>
        <button onclick="clearPoles()">T…ômizl…ô</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas boyutlarƒ±
        canvas.width = 1200;
        canvas.height = 700;
        
        // Yol konfiqurasiyasƒ± (soldan saƒüa)
        const path = [
            {x: 0, y: 350},
            {x: 300, y: 350},
            {x: 600, y: 200},
            {x: 900, y: 200},
            {x: 1200, y: 350}
        ];
        
        // Direk pozisyonlarƒ± (soldan saƒüa, yolun √ºst√ºnd…ô)
        let poles = [];
        let selectedPoleIndex = null;
        
        // D√º≈üm…ônl…ôr
        let enemies = [];
        let enemySpawnTimer = 0;
        const enemySpawnInterval = 2000; // H…ôr 2 saniy…ôd…ô bir d√º≈üm…ôn
        
        // Direk konfiqurasiyasƒ±
        const poleConfig = {
            width: 15,
            height: 80,
            spacing: 100, // Direkl…ôr arasƒ±ndakƒ± m…ôsaf…ô
            baseY: 300,   // Yolun √ºst√ºnd…ôki m√∂vqeyi
            laserColor: '#ff00ff',
            laserGlow: '#ff00ff',
            poleColor: '#00d4ff'
        };
        
        // Mouse pozisiyasƒ±
        let mouse = {x: 0, y: 0};
        
        // Direk qoymaq
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Yolun √ºz…ôrind…ô mi yoxlama
            if (isOnPath(x, y)) {
                // Yeni direk qoy (m√∂vcud direkl…ôri n…ôz…ôr…ô alaraq)
                placePole(x);
            }
        });
        
        // Mouse h…ôr…ôk…ôti
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        function isOnPath(x, y) {
            // Yolun √ºz…ôrind…ô olub olmadƒ±ƒüƒ±nƒ± yoxla (t…ôxmini 50px radius)
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                if (dist < 50) return true;
            }
            return false;
        }
        
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq != 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function placePole(x) {
            // M√∂vcud direkl…ôr…ô √ßox yaxƒ±n deyils…ô, yeni direk qoy
            let canPlace = true;
            for (const pole of poles) {
                if (Math.abs(pole.x - x) < poleConfig.spacing) {
                    canPlace = false;
                    break;
                }
            }
            
            if (canPlace) {
                // Yolun √ºz…ôrind…ôki y koordinatƒ±nƒ± tap
                const pathY = getPathY(x);
                // Direk yolun ortasƒ±nda yerl…ô≈üir (h√ºnd√ºrl√ºy√ºn yarƒ±sƒ± yuxarƒ±da, yarƒ±sƒ± a≈üaƒüƒ±da)
                const poleHeight = 100;
                poles.push({
                    x: x,
                    y: pathY - poleHeight / 2, // Direk yolun ortasƒ±nda (yarƒ± yuxarƒ±da, yarƒ± a≈üaƒüƒ±da)
                    index: poles.length
                });
                
                // Direkl…ôri x koordinatƒ±na g√∂r…ô sƒ±rala
                poles.sort((a, b) => a.x - b.x);
                poles.forEach((p, i) => p.index = i);
            }
        }
        
        function getPathY(x) {
            // Verilmi≈ü x √º√ß√ºn yolun y koordinatƒ±nƒ± tap
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                if (x >= p1.x && x <= p2.x) {
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + t * (p2.y - p1.y);
                }
            }
            return path[path.length - 1].y;
        }
        
        function clearPoles() {
            poles = [];
        }
        
        function spawnEnemy() {
            // D√º≈üm…ôni yolun ba≈ülanƒüƒ±cƒ±na yerl…ô≈üdir
            const startX = path[0].x;
            const startY = path[0].y;
            
            enemies.push({
                x: startX,
                y: startY,
                pathIndex: 0, // Hansƒ± path segmentind…ôdir
                t: 0, // 0-1 arasƒ±, segment daxilind…ô m√∂vqeyi
                speed: 1 + Math.random() * 0.5, // H…ôr…ôk…ôt s√ºr…ôti
                health: 100,
                maxHealth: 100,
                radius: 15,
                color: `hsl(${Math.random() * 60 + 0}, 70%, 50%)` // Qƒ±rmƒ±zƒ± tonlarƒ±
            });
        }
        
        function updateEnemies(deltaTime) {
            // D√º≈üm…ôn spawn
            enemySpawnTimer += deltaTime;
            if (enemySpawnTimer >= enemySpawnInterval) {
                spawnEnemy();
                enemySpawnTimer = 0;
            }
            
            // D√º≈üm…ônl…ôri yenil…ô
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Yol boyunca h…ôr…ôk…ôt
                const pathSegment = Math.floor(enemy.pathIndex);
                if (pathSegment < path.length - 1) {
                    const p1 = path[pathSegment];
                    const p2 = path[pathSegment + 1];
                    
                    enemy.t += (enemy.speed * deltaTime) / 1000 / 2; // Normalize edilmi≈ü s√ºr…ôt
                    
                    if (enemy.t >= 1) {
                        enemy.t = 0;
                        enemy.pathIndex += 1;
                        
                        // Yolu bitirdis…ô, d√º≈üm…ôni sil
                        if (enemy.pathIndex >= path.length - 1) {
                            enemies.splice(i, 1);
                            continue;
                        }
                    } else {
                        // M√∂vcud segment √ºz…ôrind…ô h…ôr…ôk…ôt
                        const currentSegment = Math.floor(enemy.pathIndex);
                        if (currentSegment < path.length - 1) {
                            const segP1 = path[currentSegment];
                            const segP2 = path[currentSegment + 1];
                            
                            enemy.x = segP1.x + (segP2.x - segP1.x) * enemy.t;
                            enemy.y = segP1.y + (segP2.y - segP1.y) * enemy.t;
                        }
                    }
                }
                
                // Lazer z…ôr…ôri
                for (let j = 0; j < poles.length - 1; j++) {
                    const pole1 = poles[j];
                    const pole2 = poles[j + 1];
                    
                    // Lazer x…ôttinin koordinatlarƒ± - YOLUN ORTASINDAN KE√áƒ∞R
                    const pathY1 = getPathY(pole1.x);
                    const pathY2 = getPathY(pole2.x);
                    const laserStart = { x: pole1.x, y: pathY1 };
                    const laserEnd = { x: pole2.x, y: pathY2 };
                    
                    // D√º≈üm…ôn lazere toxunurmu? (d√º≈üm…ôn m…ôrk…ôzind…ôn lazer x…ôttin…ô q…ôd…ôr m…ôsaf…ô)
                    const distToLaser = pointToLineDistance(
                        enemy.x, enemy.y,
                        laserStart.x, laserStart.y,
                        laserEnd.x, laserEnd.y
                    );
                    
                    if (distToLaser < enemy.radius + 5) { // Lazer eni + d√º≈üm…ôn radiusu
                        // D√º≈üm…ôn lazere toxunur - z…ôr…ôr ver
                        enemy.health -= 5 * deltaTime / 16.67; // 5 z…ôr…ôr/saniy…ô (60 FPS √º√ß√ºn)
                        
                        if (enemy.health <= 0) {
                            enemies.splice(i, 1);
                            continue;
                        }
                    }
                }
            }
        }
        
        function drawPath() {
            ctx.strokeStyle = '#444466';
            ctx.lineWidth = 60;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 0;
            
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            // Yolun k…ônarlarƒ±
            ctx.strokeStyle = '#666688';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawPoles() {
            for (const pole of poles) {
                // Direk strukturu (≈ü…ôkild…ôki kimi)
                const poleWidth = 60; // √úmumi eni
                const poleHeight = 100; // √úmumi h√ºnd√ºrl√ºy√º
                const topBarHeight = 8; // √úst √ºf√ºqi √ßubuq
                const bottomBarHeight = 8; // Alt √ºf√ºqi √ßubuq
                const verticalSpacing = 12; // ≈ûaquli dayaqlar arasƒ± m…ôsaf…ô
                const verticalWidth = 6; // ≈ûaquli dayaqlarƒ±n eni
                const verticalHeight = poleHeight - topBarHeight - bottomBarHeight - 10; // ≈ûaquli dayaqlarƒ±n h√ºnd√ºrl√ºy√º
                const centerX = pole.x;
                const centerY = pole.y;
                
                // Taxta r…ôngi (a√ßƒ±q q…ôhv…ôyi)
                const woodColor = '#8B7355';
                const darkWoodColor = '#5C4634';
                const metalColor = '#C0C0C0';
                
                ctx.save();
                
                // 1. √úst √ºf√ºqi √ßubuq
                ctx.fillStyle = woodColor;
                ctx.shadowBlur = 5;
                ctx.shadowColor = darkWoodColor;
                ctx.fillRect(
                    centerX - poleWidth / 2,
                    centerY,
                    poleWidth,
                    topBarHeight
                );
                
                // 2. Alt √ºf√ºqi √ßubuq
                ctx.fillRect(
                    centerX - poleWidth / 2,
                    centerY + poleHeight - bottomBarHeight,
                    poleWidth,
                    bottomBarHeight
                );
                
                // 3. ≈ûaquli dayaqlar (5 …ôd…ôd)
                const verticalCount = 5;
                const totalSpacing = (verticalCount - 1) * verticalSpacing;
                const startX = centerX - totalSpacing / 2;
                
                const verticalPositions = [];
                for (let i = 0; i < verticalCount; i++) {
                    const vx = startX + i * verticalSpacing;
                    verticalPositions.push(vx);
                    
                    // ≈ûaquli dayaqlar
                    ctx.fillStyle = woodColor;
                    ctx.fillRect(
                        vx - verticalWidth / 2,
                        centerY + topBarHeight,
                        verticalWidth,
                        verticalHeight
                    );
                    
                    // √úst finial (dair…ôvi b…ôz…ôk)
                    ctx.fillStyle = metalColor;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(vx, centerY + topBarHeight / 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 4. X formalƒ± diaqonal x…ôtl…ôr (orta 3 dayaqlar arasƒ±nda)
                ctx.strokeStyle = darkWoodColor;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 0;
                
                for (let i = 0; i < verticalPositions.length - 1; i++) {
                    const x1 = verticalPositions[i];
                    const x2 = verticalPositions[i + 1];
                    const yTop = centerY + topBarHeight;
                    const yBottom = centerY + topBarHeight + verticalHeight;
                    
                    // X formasƒ± - iki diaqonal x…ôtt
                    ctx.beginPath();
                    // Sol yuxarƒ± -> Saƒü a≈üaƒüƒ±
                    ctx.moveTo(x1, yTop + 5);
                    ctx.lineTo(x2, yBottom - 5);
                    ctx.stroke();
                    
                    // Sol a≈üaƒüƒ± -> Saƒü yuxarƒ±
                    ctx.beginPath();
                    ctx.moveTo(x1, yBottom - 5);
                    ctx.lineTo(x2, yTop + 5);
                    ctx.stroke();
                }
                
                // 5. Neon glow effekti (plazma enerjisi)
                ctx.strokeStyle = poleConfig.poleColor;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = poleConfig.poleColor;
                ctx.globalAlpha = 0.6;
                
                // ≈ûaquli dayaqlarƒ± neon il…ô vurƒüula
                for (const vx of verticalPositions) {
                    ctx.beginPath();
                    ctx.moveTo(vx, centerY + topBarHeight);
                    ctx.lineTo(vx, centerY + topBarHeight + verticalHeight);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        function drawLasers() {
            // H…ôr iki direk arasƒ±nda lazer √ßiz - YOLUN ORTASINDAN KE√áM∆èLƒ∞
            for (let i = 0; i < poles.length - 1; i++) {
                const pole1 = poles[i];
                const pole2 = poles[i + 1];
                
                // Lazer yolun ortasƒ±ndan ke√ßm…ôlidir
                // Direkl…ôrin yuxarƒ± n√∂qt…ôl…ôri il…ô yolun ortasƒ± arasƒ±nda lazer √ß…ôkilir
                const pathY1 = getPathY(pole1.x);
                const pathY2 = getPathY(pole2.x);
                
                // Direkl…ôrin yuxarƒ± n√∂qt…ôl…ôri
                const top1 = {
                    x: pole1.x,
                    y: pole1.y
                };
                const top2 = {
                    x: pole2.x,
                    y: pole2.y
                };
                
                // Yolun ortasƒ±ndan ke√ß…ôn n√∂qt…ôl…ôr
                const mid1 = {
                    x: pole1.x,
                    y: pathY1
                };
                const mid2 = {
                    x: pole2.x,
                    y: pathY2
                };
                
                // Lazer effekti - YOLUN ORTASINDAN KE√áƒ∞R
                ctx.save();
                
                // Lazer parƒ±ltƒ±sƒ± (glow) - yolun ortasƒ±ndan ke√ßir
                const gradient = ctx.createLinearGradient(mid1.x, mid1.y, mid2.x, mid2.y);
                gradient.addColorStop(0, 'rgba(255, 0, 255, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 100, 255, 1)');
                gradient.addColorStop(1, 'rgba(255, 0, 255, 0.6)');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 6; // Lazer eni
                ctx.shadowBlur = 25;
                ctx.shadowColor = poleConfig.laserGlow;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(mid1.x, mid1.y);
                ctx.lineTo(mid2.x, mid2.y);
                ctx.stroke();
                
                // Lazer n√ºv…ô (daha parlaq)
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffffff';
                
                ctx.beginPath();
                ctx.moveTo(mid1.x, mid1.y);
                ctx.lineTo(mid2.x, mid2.y);
                ctx.stroke();
                
                // Lazer √ºz…ôrind…ô h…ôr…ôk…ôt ed…ôn par√ßacƒ±qlar
                const time = Date.now() / 500;
                for (let j = 0; j < 5; j++) {
                    const t = ((time + j * 0.2) % 1);
                    const px = mid1.x + (mid2.x - mid1.x) * t;
                    const py = mid1.y + (mid2.y - mid1.y) * t;
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = poleConfig.laserGlow;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        function drawEnemies() {
            for (const enemy of enemies) {
                // D√º≈üm…ôn g√∂vd…ôsi
                ctx.fillStyle = enemy.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = enemy.color;
                
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // D√º≈üm…ôn can barƒ±
                const healthPercent = enemy.health / enemy.maxHealth;
                const barWidth = enemy.radius * 2;
                const barHeight = 4;
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 10, barWidth, barHeight);
                
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 10, barWidth * healthPercent, barHeight);
                
                ctx.shadowBlur = 0;
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw path
            drawPath();
            
            // Draw poles
            drawPoles();
            
            // Draw lasers between poles (yolun ortasƒ±ndan)
            if (poles.length >= 2) {
                drawLasers();
            }
            
            // Draw enemies
            drawEnemies();
            
            // Preview pole placement (mouse position)
            if (isOnPath(mouse.x, mouse.y)) {
                const pathY = getPathY(mouse.x);
                const previewX = mouse.x;
                const poleHeight = 100;
                const previewY = pathY - poleHeight / 2; // Direk yolun ortasƒ±nda
                
                // Preview strukturunu √ß…ôk (yarƒ±m ≈ü…ôffaf)
                ctx.save();
                ctx.globalAlpha = 0.6;
                
                const poleWidth = 60;
                const topBarHeight = 8;
                const bottomBarHeight = 8;
                const verticalSpacing = 12;
                const verticalWidth = 6;
                const verticalHeight = poleHeight - topBarHeight - bottomBarHeight - 10;
                
                const woodColor = '#8B7355';
                const metalColor = '#C0C0C0';
                
                // √úst v…ô alt √ßubuqlar
                ctx.fillStyle = woodColor;
                ctx.fillRect(previewX - poleWidth / 2, previewY, poleWidth, topBarHeight);
                ctx.fillRect(previewX - poleWidth / 2, previewY + poleHeight - bottomBarHeight, poleWidth, bottomBarHeight);
                
                // ≈ûaquli dayaqlar
                const verticalCount = 5;
                const totalSpacing = (verticalCount - 1) * verticalSpacing;
                const startX = previewX - totalSpacing / 2;
                
                for (let i = 0; i < verticalCount; i++) {
                    const vx = startX + i * verticalSpacing;
                    ctx.fillRect(vx - verticalWidth / 2, previewY + topBarHeight, verticalWidth, verticalHeight);
                    
                    // Finial
                    ctx.fillStyle = metalColor;
                    ctx.beginPath();
                    ctx.arc(vx, previewY + topBarHeight / 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = woodColor;
                }
                
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
            
            // Info text
            ctx.fillStyle = '#00d4ff';
            ctx.font = '14px Arial';
            ctx.fillText(`Direkl…ôr: ${poles.length}`, 10, canvas.height - 60);
            if (poles.length >= 2) {
                ctx.fillText(`Lazer sayƒ±: ${poles.length - 1}`, 10, canvas.height - 45);
            }
            ctx.fillText(`D√º≈üm…ônl…ôr: ${enemies.length}`, 10, canvas.height - 30);
            
            // Lazer z…ôr…ôri m…ôlumatƒ±
            let totalDamage = 0;
            for (const enemy of enemies) {
                if (enemy.health < enemy.maxHealth) {
                    totalDamage += enemy.maxHealth - enemy.health;
                }
            }
            ctx.fillText(`C…ômi z…ôr…ôr: ${Math.floor(totalDamage)}`, 10, canvas.height - 15);
        }
        
        // Animation loop
        let lastTime = Date.now();
        
        function gameLoop() {
            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // D√º≈üm…ônl…ôri yenil…ô
            updateEnemies(deltaTime);
            
            // √á…ôkil…ôc…ôk elementl…ôri √ß…ôk
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>
